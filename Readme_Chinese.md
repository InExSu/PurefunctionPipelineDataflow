[goto English edition (英文版)](./README.md)

# 大统一编程理论：纯函数管道数据流和基于原则的仓库/车间模型

版权所有 © 2018 林鹏程， 保留所有权利。

## 目录

- [我的和其他人的相关观点](#我的和其他人的相关观点)
- [概述](#概述)
- [基本构造方法](#基本构造方法)
  - [1. 管道组件](#1-管道组件)
  - [2. 分支](#2-分支)
  - [3. 反馈电路（回流, 漩涡, 递归）](#3-反馈电路)
  - [4. 分流(并发, 并行)](#4-分流)
  - [5. 合流, 合一](#5-合流)
- [代码范例](#代码范例)
- [经典模型](#经典模型)
  - [仓库/车间模型](#仓库车间模型)
    - [模型的概述](#模型的概述)
    - [模型的原则](#模型的原则)
    - [模型的框架代码](#模型的框架代码)
    - [编程技术和系统架构的统一](#编程技术和系统架构的统一)
    - [单线程、多线程、异步、分布式大统一](#单线程-多线程-异步-分布式大统一)
      - [`async/await`, `Project Loom 纤程`, `甘特图`和`科学管理`](#async)
      - [`微服务`和`智能线程`的统一](#微服务和智能线程的统一)
    - [和`信息系统集成模型`的统一](#和信息系统集成模型的统一)
    - [和`微内核架构`的统一](#和微内核架构的统一)
    - [和`AOP`的统一](#和AOP的统一)
    - [和`事件驱动架构`的统一](#和事件驱动架构的统一)
    - [和`计算机硬件体系`的统一](#和计算机硬件体系的统一)
    - [和`集成电路系统`的统一](#和集成电路系统的统一)
    - [和`语言平台`的统一](#和语言平台的统一)    
    - [和`Clojure Web应用程序模型`的统一](#和Clojure-Web应用程序模型的统一)    
    - [和`生命周期管理`的统一](#和生命周期管理的统一)
    - [与`经典AI和现代AI技术`的统一](#与经典AI和现代AI技术的统一)
    - [与`能源体系`的统一](#与能源体系的统一)
    - [与`现代经济社会运行体系`的统一](#与现代经济社会运行体系的统一)
    - [和`其他模型`的统一](#和其他模型的统一)    
    - [小结](#小结)
- [它和其它方法的区别](#它和其它方法的区别)    
  - [函数式编程和面向对象编程的缺点](#函数式编程和面向对象编程的缺点)
  - [它和中间件的区别](#它和中间件的区别)
  - [它和Rx的区别](#它和Rx的区别)
  - [它和传统FP语言里的类unix管道操作符的区别](#它和传统FP语言里的类unix管道操作符的区别)
- [基本质量控制](#基本质量控制)
- [编程美学](#编程美学)
- [道](#道)
- [杀手级的应用](#杀手级的应用)
  - [软件设计和开发自动化 (SDDA)](#软件设计和开发自动化)
- [重大历史意义](#重大历史意义)
- [后记](#后记)
- 附录:
  - [简单性和统一性----大统一理论, Lisp(Clojure) 与纯函数管道数据流](doc/Simplicity_and_Unity.md)
  - [Clojure是基于关系式数据库理论的函数式编程语言](doc/Clojure_is_FP_based_on_RMDB.md)
  - [一切都是RMDB](doc/Everything_is_RMDB.md)
  - [在hash-map(NoSQL)的基础上实现关系式数据模型和编程](doc/relational_model_on_hashmap.md)
  - [不破坏编程语言语法的Markdown文学编程](doc/markdown_literary_programming.md)
  - [其他文章目录](#其他文章目录)

----

## 我的和其他人的相关观点

```
大道至简，万法归宗。
        ---- 林鹏程

NASA的10大编程规则：第一条：用非常简单的控制流结构体来编写程序。
        ---- NASA 喷气推进实验室（JPL）的首席科学家 Gerard J. Holzmann
       
最小化控制流复杂性和“ifs下的区域”，倾向于一致的执行路径和时间, 
而不是 "最优化", 以避免不必要的工作。。
       ---- 约翰 卡马克       

Clojure格言：交织的变化网意味着，代码的任何变化都可能会在更大层面上产生影响。
        ---- Clojure编程乐趣(第2版)第10章
        
糟糕的程序员关注代码。优秀的程序员关注数据结构及其关系。
       ---- Linus Torvalds

数据占主导地位。如果您选择了正确的数据结构并组织好了，那么算法几乎总是不言自明的。
数据结构才是编程的核心, 而不是算法。
        ---- Rob Pike

围绕一个数据结构开发100个函数, 比设计10个带10个函数的数据结构更好.
       ---- Alan Perlis, 首届图灵奖得主 (1966), 使计算机科学成为独立学科的奠基人
       
告诉我您的流程图并隐藏数据表，我将继续感到困惑。
给我看你的数据表，我通常不需要你的流程图。他们会很明显。      
        ---- Fred Brooks, 图灵奖(1999), 人月神话

即使是最简单的程序逻辑对于人类来说也难以验证，但非常复杂的数据结构却相当容易建模和推理。
...
数据比程序逻辑更容易处理。接下来，您可以选择数据结构的复杂性和代码的复杂性，选择前者。
更多：在设计的演变过程中，您应该积极寻求将复杂性从代码转移到数据的方法。
        ---- Eric Steven Raymond, Unix编程的艺术, Unix哲学的基础知识

善于在软件开发中运用比喻。
       ---- "代码大全"最有价值章节(第二章)
       
基于原则比基于规则更好。
       ----国际会计准则
``` 

## 概述

利用纯函数的输入输出特性当作管道（导线）使用。
数据经过一系列串联的纯函数形成数据流。
一个数据流代码块作为一个函数，相当于一个集成电路元件（或板）。
通过串联或并联数据流，形成一个完整的集成系统。

也可以换种说法，数据和逻辑严格分离，数据和逻辑的元素级分离，数据流处理。

```clojure
(defn f [[evens odds total amax amin] x]
  (let [[evens odds] (cond 
                       (even? x) [(inc evens ) odds]
                       (odd? x)  [evens (inc odds)]
                       :else     [evens odds])
        total (+ total x)
        amax  (max amax x)
        amin  (min amin x)]   
     [evens odds total amax amin]))

(reduce f [0 0 0 ##-Inf ##Inf] [5 6 8 -3 -9 11 156 6 7])

;;[4 5 187 156 -9]
```

对我来说，编程就是设计一个操纵简单流畅的数据模型的过程，
在我的项目里，80%以上的函数是由`->>`这类数据流线程宏代码块组成。
每一步都是很简单、可验证、可测试、可替换、可插入、可扩展，
而且容易实现多线程处理。
Clojure的提供的很多种类线程宏，还有极简单流畅的数据操作函数，
对纯函数管道数据流提供了语言级的支持。

大海航行靠舵手，编程朝着数据走。初始状态，最终状态，两点间直线距离最短。简单直接是快速稳定可靠的根本。

```
故善战者之胜也，无智名，无勇功，故其战胜不忒。
(曹操批注: 善战者无赫赫之功。)
        ---- 《孙子兵法.形篇》
```

曾国藩打仗的要诀:"结硬寨，打呆仗。" 与工业流水线、纯函数管道数据流的设计哲学是一致的，
本质上都是对准目标，步步为营，每一步都向最终目标前进一步, 直至达到最后目标。
因此, 它的成功是必然的, 毫不令人惊奇的, 过程是平淡的简单重复.
这种方法用熟了，真是一项简单和重复的无聊技术，这就是大工业生产线追求的简单与重复。


## 基本构造方法

### 1 管道组件

管道函数都是纯函数, 一个->>块函数相当于一个集成电路元件（或板）。 

- 副作用
  - 一个`->>`块里面的一系列函数，绝大多数都是纯函数。 
  - 最多只能有两个带副作用的函数且只能处于头尾。
  - 在`仓库/车间模型`中, 副作用由专门的IO部门(采购部门,销售部门)负责。
    因此,所有的车间(管道)都是纯函数, 只与仓库交互, 并由仓库调度。 

- 参数
  - 在入口检查并标准化数据，随后就可以极限速度运行
    这样做简洁、流畅、稳定、高效。
  - 在Clojure语言中，建议将函数尽可能设计为hash-map类型的单参数函数。
    - 象R语言大多数函数那样，可以设计很多带默认值的命名参数， 
      有很强的可扩展性。 
    - Clojure操作hash-map的核心函数很多，非常方便。 
    - 在使用->>宏时可以不用写括号。
      这样, Clojure就成为括号最少的编程语言:-)
    - 参数的形成，校验，变换与函数调用一体化、一条龙数据流处理。
    - Clojure解构方便，在使用上与多参数函数是一样方便的。

```clojure
(defn f [x]
  (->> x
       f1
       f2))
```

```clojure
(defn f [{:keys [x y] :as m}]
  (->> x
       (f1 y ,)
       f2))
```

### 2 分支

一个(cond)或(if)块作为一个函数。

```clojure
(defn f [x]
  (cond
    (= x 1) (f1)
    (= x 2) (f2)
    :else   (f3)))
```
```clojure
(defn f2 [x y]
  (-> (> x 2)
      (and , (< y 6))
      (if , 25 30)))
```
```clojure
(defn path-combine [s1 s2]
  (cond
    (string/starts-with? s2 "/") 
      s2
    (not (string/ends-with? s1 "/"))
      (-> (string/split s1 #"[\\/]")
          butlast
          (#(string/join "/" %))
          (str , "/")
          (path-combine , s2)) 
    :else  
      (-> (string/join "/" [s1 s2])
          (string/replace ,  #"[\\/]+" "/")))) 
```

### 3 反馈电路

反馈电路（回流, 漩涡, 递归）:
一个尾递归函数相当于一个反馈电路。

备注：map是批处理，可以看成类似对一个游客队列，在入口重复进行验票动作，
是一个前进动作，不是反馈或回流。

```clojure
(defn f [i]
  (if-not (zero? i)
    (f1)
    (-> i dec recur)))
```

### 4 分流

分流（并发，并行）,例如：对数据进行分块，并行处理

```clojure
(->> data
     (partition n ,)
     (pmap f ,))
```
```clojure
(->> [pipe-f1 pipe-f2 pipe-f3]
     (pmap #(% data) ,))
```

### 5 合流

合流，合一: 对分流的结果进行reduce： 

```clojure
(->> data
     (partition n ,)
     (pmap f1 ,)
     (reduce f2 ,))   
```


## 代码范例

### 代码范例 01

```clojure
;Traditional expression, chaotic logic, unreadable.
(if (and (> x1 x2)
         (or (< x3 x4) 
             (and (or (> y1 y2) 
                      (< y3 y4))
                  (not= x5 x6)))
         (keyword? x7)) 
  :t
  :f)

;Pure Function Pipeline Dataflow
;Unrestricted expression, just read in order. 
;Closer to the order of execution of the machine.
(->  (> y1 y2)
     (or  , (< y3 y4))
     (and , (not= x5 x6))
     (or  , (< x3 x4))
     (and , (> x1 x2))
     (and , (keyword? x7))       
     (if  , :t :f))
```

### 代码范例 02

```clojure
(def data
  {:a [[:b :c :d]
       [:e :f :g]
       [:h :i :j]]
   :k [[:l :m :n]
       [:o :p :q]
       [:r :s :t]]})

(defn f1 [[k v]]
  (let [[h & t] v
        f   (fn [x] (mapv #(vector :td %) x))
        tds (map #(->> % f (into [:tr] ,)) t)]
     (->> (f h)
          (into [:tr [:td {:rowspan (count v)} k]] ,)
          (conj tds ,))))

(->> data
     (reduce #(->> %2 f1 (into %1 ,)) [:tbody] ,)
     (conj [:table] ,)
     hiccup/html)

```

<table>
    <tbody>
       <tr><td rowspan=3>a</td>
           <td>b</td>
           <td>c</td>
           <td>d</td></tr>
       <tr><td>e</td>
           <td>f</td>
           <td>g</td></tr>
       <tr><td>h</td>
           <td>i</td>
           <td>j</td></tr>
       <tr><td rowspan=3>k</td>
            <td>l</td>
            <td>m</td>
            <td>n</td></tr>
       <tr><td>o</td>
            <td>p</td>
            <td>q</td></tr>
       <tr><td>r</td>
            <td>s</td>
            <td>t</td></tr>
    </tbody>
</table>

## 经典模型

```
智力的真正标志不是知识，而是想象力(类比)。
        ---- 爱因斯坦
```

类比是一种代数思维的应用。类比在真实世界不一定能成立, 但在虚拟的软件世界里它一定能成立，
把一个旧模型映射为一个新模型, 并按新模型的标准规范实现升级改造, 这是很容易的.
在管理学,叫做"吸收合并". 在金庸的武侠小说《天龙八部》里, 叫"北冥神功".
在《西游记》里, 叫"天罡地煞变".

这是`道`和`大统一理论`的哲学的典型应用:

- 数据流是电流，函数是芯片，线程宏（->>, -> etc.）是导线，整个系统就是通电工作的集成电路。
- 数据(流)是原料(流), 纯函数是机器, 线程宏（->>, -> etc.）是传送带, 整个系统是大工业流水线.
- 通信模式, 数据信号和控制信号(注解或元数据)在管道里流转.
- 编译器本质上就是数据变换，从源码开始，经过一系列纯函数管道的变换优化，直至机器码.非常容易插入增强优化或特性, 实现并行编译也很简单.
- 城市的自来水网
- 管理学是最好的,最生动的计算机科学的宝库(算法、架构、异步、并行和分布式等等). 
  我的编程方法是“函数式编程”和“企业管理”的融合。它有一个额外的好处，
  它对信息技术部门和公司管理层之间的沟通非常有帮助。
  - 管理学里的**甘特图**, 以时间线为主轴, 多个数据流并行前进. 它也是很好的数据流、并行、异步编程工具.
  - 并行: 大工业流水线可以线性并行扩展.
  - 分布式: 集团公司模型, 总分公司模式,母子公司模式, 控股公司模型等.
  - 组织架构: 
    - 金字塔式: 经典的自顶向下模块化设计:
    - 扁平式: 纯函数管道数据流, 代码只有函数和数据两层, 模型也只有仓库和车间两层.
    - 矩阵式: 面向切面编程(AOP)
    - 业务流程外包: 函数式编程(FP), FP不仅用本公司函数完成任务,而且还存在高阶函数这样不干活的部门,
      但可以把任务委托给"作为参数的外包公司函数".
      
      ```clojure
      (own-department-function  task-list)

      (apply outsourced-company-function task-list)
      ```
      
    - 混乱的P2P (点对点对等网络): 面向对象编程(OOP)
  - 操作系统或资源管理: ERP
  - 类型系统: 工业标准体系(ISO标准,国家标准，行业标准，企业标准)，纯函数管道数据流适合产品规范(数据规范)工业标准体系的实施,
    就象计算机硬件接口标准规范一样, 硬件是函数, 接口是数据标准规范 在硬件(函数)间传输数据.。
  - 存储管理(缓冲区, 缓存, 数据库, 等等)：库存管理.
  - 在大型企业中, 流程第一思想, 是建立在凭据(证据)的基础上的, 这个凭据就是数据, 凭据(数据)在流程中各节点流转, 形成数据流. 
    流程中的每一个节点就是管道函数(纯函数), 这就是`纯函数管道数据流`.
  - 波音公司的脉动生产线技术, 就象长江从源头出发, 沿途汇流, 百川东到海. 它也是**甘特图**的一个变种.
    
![Gantt chart](./doc/image/GanttChart.jpeg) 

![River](./doc/image/river.jpeg) 


<h3 id="仓库车间模型">仓库/车间模型</h3>

![Warehouse Workshop Model](./doc/Warehouse-Workshop-Model-v2.svg)

#### 模型的概述

如果能够理解软件是生产数据的工厂, 那么就能理解仓库/车间模型,
理解生产线(纯函数,管道)和生产原料(数据)相分离, 
生产线持续生产形成数据流的开发思想.

系统的基本原理类似一个内存数据库系统，
这个系统的所有任务由内存数据库调度存储过程（车间）完成，
所有的副作用（类似持久化、分布式等）由内存数据库完成。

尽一切可能编写纯函数（管道），
并且只能使用“管道符号”将它们链接在一起，
只要做到这一点，它最终就会演变成这种结果。

如果没有“管道符号”，则可以使用“赋值语句”，
它可以在任何语言都适用。

- **一切都是管道**: 实现软件生态系统简单性和统一性的完美方法。

  - **管道组合**: 串联的`简单管道`形成`车间管道`
  
  - **车间组合**: 
    - 并联的独立的`车间管道`通过`仓库`协作(调度)形成`仓库/车间模型管道(数据工厂)`。
    - 车间管道可以作为`封装的集成管道(集成芯片)`独立对外提供服务,这就是`微服务`和服务业.
      - 所有车间都是独立的黑匣子（纯功能），它不需要知道数据哪里来、到哪里去，
        只需根据仓库分配给它的数据完成它的职能即可。
      - 它们都是独立的，可以安全地并行。

    
  - **仓库**: 
    - 可以作为独立体对外提供服务, 这就是仓储业和数据库服务。 
    - 仓库根据状态变化（如订单等）使用甘特图的最佳算法安排车间完成任务。
    - 仓库保存了全局状态，如果系统发生故障时，通过分析仓库快照可以很方便找出故障。
    - 所有副作用（可以看成是特殊的车间：采购部门和销售部门等）均由仓库代理完成，
      类似根据需要向其他仓库获取数据（分布式数据库，磁盘等），持久化数据等。
    
  
  - **仓库/车间模型组合**: 
    - 各种独立的`仓库/车间模型管道(数据工厂)`可以作为一个`封装的集成管道(数据工厂,集成芯片)`
      再组合成一个更大的`仓库/车间模型管道(数据工厂)`, 
    - 这就是不同开发商、不同软件产品互联、协作、集成的方法，也是软件开发标准化大工业生产的基础。
    - 这就是企业集团或整个工业生态系统。
    
  - 最后，管道就象是细胞一样，
    组合成一个符合现代工业生态系统要求的管道软件生态系统，
    这就是简单性和统一性的完美体现。
    
  - 对比`一切都是对象`
    - 对象是一个毛毛球, 对象之间是混乱的点对点网络, 它是一个复杂的、混乱的、无组织的系统.
    - 管道是单向的射线, 数据标准化和组合是最简单的, 它是一个简单的、可靠的、有序的、可观测的、可验证的系统.

- 因为软件是生产数据的工厂，所以现代工业体系适用于软件体系。

- 仓库（数据库，池）/车间（管道）模型是一个简单实用的模型，而且大型工业流水线是世界上主流的生产技术。

- 最好的任务计划工具是甘特图，最好的实现方法是工厂实行的仓库/车间模型。

#### 模型的原则

- 任务分工
  - 按甘特图划分任务
  - 一种类型的任务只由对应类型的车间负责
  - 数据管理由仓库负责
  - 任务调度由仓库的调度函数负责。

- 单一领导和统一调度  
  - 单一领导
    - 除了根仓库, 所有的组件(车间,仓库,模型)都有且仅有一个领导(仓库的调度函数).
    - 单一领导有助于增强任务执行(路径、时间和结果)的确定性和可预测性.
    - 多领导会使任何一个领导对任务的执行失去掌控, 产生不可预期的结果, 
      并破坏利用动态规划实现全局优化的成果.
  - 统一调度
    - 由仓库的调度函数统一调度
    - 调度函数按甘特图算法动态规划任务的完成顺序，
      据以调用车间完成分派的任务。
    - 这种做法实现系统整体效率的最优化是最简单的。
    
- 充分授权和目标管理
  - 充分授权
    - 我认为充分授权就是要达到类似导弹“发射后不管”技术的效果。
      “发射后不管”是指导弹有自主引导能力，不需要外界的支持，
      便会自动跟踪，打击目标，不用发射后再去控制。 
      具有提高武器与发射载具之间的使用效率，
      降低武器依赖 其他系统提供本身的更新资料，
      让发射载具可以在最短的时间之内攻击数量最多的目标、
      提高发射载具的生存性等重要性。 
      今后制导技术的发展方向正是“发射后不管”的精确制导技术。
    - 如果特定的任务车间不能做到“发射后不管”, 
      尚需管理者(调度函数)参与管理控制,
      那么说明任务划分不合理, 应在管理者(调度函数)介入点分割任务.
    - 充分授权后, “发射后不管”的优点
      - 可以降低系统复杂度,
      - 增强模型内各组件的独立性,各司其职,互不干扰, 增强组件的简单性和可并行性.
      - 使任务划分在保证独立性的前提下达到最大粒度, 保证任务执行的连续性和效率
      - 提高并行,并发,分布式,异步等的效率
      - 统一并行,并发,分布式,异步等的架构
      - 强化全局调度的优化效果
      - 统一管理者(调度函数)对车间的管理控制形式.
      - 实现系统的简单性和统一性.
  - 目标管理
    - 充分授权不是放任不管, 主要是对工作结果进行严格的标准化的全面质量管理.
    - 只要保证仓库数据的准确性, 就能保证车间输入输出的准确性, 进而保证系统的准确性.
    - 仓库的验收函数负责这个职能.
  
- 单一形式
  - 一切组件(车间,仓库,模型)都是管道.
  - 实现系统的简单性和统一性完美结合.
  - 类似
    - 由无数个最简单的细胞组成一个复杂的生命体.
    - 由亿万个最简单的晶体管组成一个复杂的CPU.

- 集中与分散
  - 数据由仓库集中管理。
  - 数据的处理由各车间独立生产，
    各车间之间不存在任何交互，仅对仓库负责。
  - 以最优化的算法调度车间完成系统任务，由仓库的调度函数负责。

- 等级链
  - 在一个`仓库/车间模型`里，所有的车间都由一个仓库的调度函数管理。
  - 每一个`仓库/车间模型`都可以当作一个车间组件(集成管道，如同集成芯片)，
    由上一级仓库的调度函数管理。

- 明确
  - 每个车间应该有明确的输入数据(参数)和输出数据(返回值)的标准规范。
  - 每个`仓库/车间模型（仓库）`对外部环境都有明确的输入/输出数据的标准规范。

- 有序
  - 每个车间通过管道(纯函数)把初始状态一步一步地向目标状态转化，
    最终返回给仓库。
  - 整个系统的任务，由调度函数按甘特图算法动态规划任务的执行顺序，
    据以调用车间完成分派的任务。
  - 整个系统持续运行, 顺序化后的效果图就象是一条河流的水系图, 它也是**甘特图**的一个变种, 
    这就是波音公司的飞机脉动式装配生产线技术，它本质上就是一条优化后的流水装配生产线。
    - 主干河流是主生产线
    - 每一条支流都是大部件生产线
    - 如果我们把河流(生产线，车间)划分几个重要的阶段，
      每完成河流(生产线，车间)一阶段的工作，
      就向最终产品接近一步，直至终点，获得最终产品。
    - 模块化设计和制造，支流汇入上一级河流的点，
      就是把大部件装配到上一级产品的点。
    - 每一个车间输出的数据都经过仓库的验收函数的验收，
      进而保证每一个车间输入的数据的正确性和标准性，提升系统的效率和质量。
      
    ![River](./doc/image/river.jpeg) 

- 标准化
  - 所有数据都按标准规范进行生产和组织。
  - 可以在执行时减少不必要的数据检测、清洗、转换、异常等处理，使车间的逻辑保持简单和高效。

- 例外处理
  - “例外”情况和问题是指各车间难以自身调节的或原设计中未列入的新情况、新问题。
    - 正常的标准化生产的车间没有“例外”情况和问题。
    - 特殊的副作用车间负责输入和输出，可能产生“例外”情况和问题，车间应解决自身能解决的“例外”情况和问题，
      实在不能处理的例外“例外”情况和问题才提交给直接管理者(仓库的调度函数)，提交时应提供详细的异常信息和可能的处理方案。
    - 调度函数可能要协调车间之间的“例外”情况和问题，类似RMDB里的事务管理和死锁处理。
  - 管理者(仓库的调度函数)应避免处理具体的工作，这由车间负责。
  - “例外”情况和问题可以由管理者(仓库的调度函数)派遣(或设立)专门处理例外的车间处理。
    - 处理例外的车间: 类似RMDB里的事务管理器和死锁处理器.

#### 模型的框架代码

```clojure

;workshop is pipeline(pure function)
;It is run after the scheduler allocates the initial data (parameter), 
;and its output data (return value) is also "received" and "processed" by the scheduler.
(defn workshop [init_data]
  (->> init_data
       pure_func_01
       pure_func_02
       pure_func_03))
       

(def warehouse (atom {}))

(defn scheduler [key reference old-state new-state]
  ;1. According to the new status (such as orders, etc.) 
  ;   scheduling workshops to complete tasks.
  ;2. Side effects: 
  ;   2.1. Interact data with other warehouses as needed 
  ;        (distributed,  other databases, disk, etc.), 
  ;   2.2. persist data, etc.
)

(add-watch warehouse :scheduler scheduler)

```

万法归宗 ---- 一切的终极大统一:

#### 编程技术和系统架构的统一

  ```
  程序 = 算法 + 数据结构
       ---- Niklaus Wirth, 图灵奖(1984), Pascal之父
       
  围绕一个数据结构开发100个函数, 比设计10个带10个函数的数据结构更好.
       ---- Alan Perlis, 首届图灵奖得主 (1966), 使计算机科学成为独立学科的奠基人
  ```
  - 仓库: 数据结构, 数据库. 显然, 数据库应尽可能是全局唯一的.
  - 车间: 算法, 函数 
  - 扩展案例
    - UI架构: 所有的组件围着一个atom状态交互，比各个组件管理自己的状态好。
      - 仓库: 包括全部界面组件状态atom数据, 类似Alan Perlis的"一个数据结构".
      - 车间: 各独立组件, 类似Alan Perlis的"100个函数".

#### 单线程 多线程 异步 分布式大统一
  
  “发射后不管”是指导弹有自主引导能力，不需要外界的支持，
  便会自动跟踪，打击目标，不用发射后再去控制。
  具有提高武器与发射载具之间的使用效率，降低武器依赖
  其他系统提供本身的更新资料，让发射载具可以在最短的时间之内
  攻击数量最多的目标、提高发射载具的生存性等重要性。
  今后制导技术的发展方向正是“发射后不管”的精确制导技术。
  
  同理, 我认为并发、并行编程技术发展方向也是 “发射后不管”，
  从过去关注代码功能开发转变为数据控制、数据流管理、数据生命周期管理、
  数据标准化体系、流程改进（流程再造）、线程协同优化等。
  
  现有的务实的 “发射后不管”并发、并行技术: 软件事务内存(STM), 多版本并发控制(MVCC), git.  
  
  - 产品：标准化的数据
  
  - 仓库: 数据管理和收发, 类似: `企业仓库（数据库）` + [`制造执行系统`（MES，Manufacturing Execution System）](https://wikimili.com/en/Manufacturing_execution_system) =  数据库 + 数据库管理系统
    - MES: 调度中心, 
      - 它相当于增强支持运筹学的ForkJoinPool, 它可以按任务关系最优化任务的完成顺序和资源分配,  以最快速度完成任务和最高效率地运用资源.
      - 可以做为车间，但与仓库集成在一起做为数据库管理系统，数据库管理系统和数据库的组合在一起比较合理，性能也更高。
      - 按订单(生产计划), 自定义的任务关系和优化策略, 或库存水平通知线程生产数据
      - 把数据发送给线程, 如果线程不存在, 则创建一个线程.
      - 发送数据后不管.
     - 数据存储
       - 任务数据队列
       - 自定义的任务关系和优化策略
       - 订单(生产计划)
    
  - 车间: 智能线程, 超微服务. 它们可以是进程, 系统线程, Project Loom纤程
    - 因为`发射后不管`, 线程应具有自主性和智能性, 所以称为`智能线程`.
    - 除了接受输入数据, 输出数据. 与外界隔离, 数据交接后不管.
    - 被动生产: 精益生产，JIT（Just In Time）生产, 按订单(生产计划)生产，追求零库存和快速反应.
    - 主动惰性生产: 当仓库(缓存)数据低于最低库存水平时, 
      开始生产数据填充仓库，达到最优库存水平为止.  
      
  - 分布式案例：[`Flink Stateful Functions`](https://ci.apache.org/projects/flink/flink-statefun-docs-release-2.0/concepts/distributed_architecture.html)
  
    - `Flink Stateful Functions`更像我以前的文章：
      [一切都是RMDB](./doc/Everything_is_RMDB.md)。

    - 在`仓库/车间模型`中，每个车间之间是严格没有交互的，而`Flink Stateful Functions`的示意图好象是有交互的。
      从这个角度来看， `Flink Stateful Functions` 仅定义了仓库，而没有严格定义车间。
      它是一个状态服务器，与Clojure ring Web服务器更相似。
      [Clojure Web应用程序模型：Ring也是`仓库/车间模型`](#Clojure-Web-Application-Model)

    - 在`仓库/车间模型`中，绝大多数车间是管道（纯函数）或由串联的管道组成的长管道。如果不是，那么，副作用处于“串联的管道”的末尾，
      类似于，办公用品或润滑油等消耗品从仓库发送到车间后，被消耗了。
      
    - `Flink Stateful Functions` 没有强调双向“发射后不管”。
      
    - 最后，我认为如果 `Flink Stateful Functions` 更严格地遵循`仓库/车间模型`，它的架构会更好更简单。
    
    - [在 clojureverse 论坛上的相关讨论](https://clojureverse.org/t/fire-and-forget-the-unification-of-single-threaded-multi-threaded-and-asynchronous-programming-technology/6032)

<h5 id="async">async/await, Project Loom 纤程, 甘特图和科学管理</h5>

我认为异步是不必要的，`async/await`是一种落后的、必然会被淘汰的模式。

从**运筹学**的角度看, 应该废除`async/await`.。当需要等待时，本线程该结束了.
例如在工厂里，不会发生一个车间在生产流程中途停下来, 蹲在另一个车间门口等米下锅，每个车间都只与仓库交互，
主线程（也是车间）发出订单数据后，由仓库生成生产计划，据此发送数据（消息）到相关车间生产，
直至完成任务， 在整个过程中没有发生等待，只是根据订单生成生产计划，以仓库为中心，各车间独立并行生产。
  
因此, 异步技术从管理学的角度上看, 了解情况的人, 知道他们在等待生产原料;
不了解情况的人, 可能误以为他们是在罢工. 但无论如何都极大地浪费资源.
  
如果在一个操作（线程，异步线程，纤程）内存在等待，
那肯定是操作设计或或系统资源配置比例不科学。
如果存在任务（数据）未完成的情况下，
所有的工人（线程，异步线程，纤程）不允等待。
这是科学管理的最基本要求.

[科学管理](https://baike.baidu.com/item/%E7%A7%91%E5%AD%A6%E7%AE%A1%E7%90%86)致力通过运筹学提高劳动生产率。
它把操作划分成不可分割的单调的操作（线程，异步线程，纤程），
然后根据资源设计最优的操作组合以达到最大效率。
其中在一个操作（线程，异步线程，纤程）内不允许等待，
这是最基本要求，这种做法也最方便进行整体协调和优化。
最重要的设计工具是甘特图。
最好的实现方法是工厂实行的仓库/车间模型，
这也是ForkJoinPool（纤程的基础技术）原理，
但设计者没有意识到这点，
并没有在使用指南里做出指导。

在“甘特图”里一个任务（图里的一个条块，线程，纤程）内部是不存在等待的，所有的等待都是全局的.
当等待时，那个任务（图里的一个条块，线程，纤程）就结束了，
当获得资源继续工作时，已经是一个新的任务了（图里的一个条块，线程，纤程）。
“async/await”在一个任务（图里的一个条块，线程，纤程）内部存在wait，完全是错误的。
“async/await”完全不符合“运筹学科学”([ref01: wiki](https://en.wikipedia.org/wiki/Operations_research), 
[ref02](https://whatis.techtarget.com/definition/operations-research-OR))
的最基本的原则，我不认为不科学的模式能产生更高的效率。

在甘特图里, 等待点把一个大任务划分成许多最小的独立的小任务, 
一个小任务就是一个条块,一个条块就是一个车间, 
一个车间就是一个管道, 一个管道就是一个纯函数或等价纯函数.

车间除了在开始时从仓库获得输入参数, 在结束时向仓库提交输出数据外, 
车间之间是互相独立的, 车间与外部环境无关的, 
它们无须知道是否有等待, 是否有上一步骤或上一步骤.

在这种模式里, 系统调度中心(仓库)可以安全地以最优的算法统筹安排任务的完成顺序.

这是一个[`制造执行系统`（MES，Manufacturing Execution System）](https://wikimili.com/en/Manufacturing_execution_system).

"async/await"只是一种无组织的、无纪律的、不严谨的、不安全的做法。

最典型的案例：
亚马逊竟用AI监控和调度员工，效率低当场开除。

这种方法不会耗尽资源（线程）或最终阻塞，
因为仓库（+调度中心＝DBMS）会按最优组件（数据）生产比例
来安排在系统最大限度的工人（线程，异步线程，纤程）的数量进行生产，
它们是独立和互不干扰的，它们只负责做好自已的工作就可以了，
不用在生产时还要费心去观察和等待资源，
那由仓库（+调度中心＝DBMS）专门负责。

这与ForkJoinPool的基本原理是一致的。

- 它使用了一个无限队列来保存需要执行的任务
- 使用一个内部队列来对需要执行的任务
  以及子任务进行操作来保证它们的执行顺序。
- ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务
- 把一个“大任务”拆分成多个“小任务”，并将任务交给ForkJoinPool来执行  

纤程与异步没有必然的直接的关系。
纤程由两个部分组成-连续部分和调度程序。
由于Java已经具有出色的调度程序，
其形式为ForkJoinPool，
将通过向JVM添加延续来实现光纤。

ForkJoinPool使用的就是仓库/车间模型，及科学管理的运筹学，在前文已经提及。
我的算法类似于“Project Loom”，相当于数据驱动版的“Project Loom”。

纤程更象是uber司机，不是uber雇员（系统线程 ），
不需要负担最低工资、带薪病假和失业补助等福利，没有成本。
所以uber几乎可以将uber司机（纤程）视为无限资源，
调度uber司机（纤程）完成任务。

结论

我只是反对在一个线程里出现等待，
认为等待点是线程的自然边界，
当出现等待时应当结束线程。等待点后面的处理，
那由调度中心按需要发出新的线程来解决。

##### 微服务和智能线程的统一

参考[单线程、多线程、异步、分布式大统一](#单线程-多线程-异步-分布式大统一), 每一个智能线程都是一个微服务.
  
  - 产品：标准化的数据
  
  - 仓库: 数据管理
    
  - 车间: 智能线程, 微服务.
  
#### 和信息系统集成模型的统一

很多大企业有不同厂家生产的独立信息系统，需要整合集成。

  - 车间：各个独立的系统  
  - 仓库：信息系统集成层作为独立系统。
    - 企业全局数据统一的抽象层（虚拟数据库，虚拟数据仓库），
      任一系统的外部数据请求皆向此系统求，而无需知道来自那个系统，实现全局系统的统一性。
    - 系统互联与数据路由的中间层。
    - 隔离变化：当一个系统变动时，不会导致其他系统的连锁变动。
    - 把复杂性集中在一个地方，比在所有地方束手束脚，按了葫芦起了瓢好。
    - 使各系统保证独立性，进而实现各系统的简单性。
    - 最终达到全局系统的简单性和统一性。
  - 扩展案例
    - OS提供了大量的编程接口给开发者使用，但如果os接口变更可能比较频繁，如添加方法或者变量等，
      但以前开发的应用很可能使用OS老版本的API。方案：直接独立开发一个版本兼容层，放开手脚干OS
      - 仓库：独立的版本兼容层
      - 车间：OS, 应用, 编程语言等
    - Intel的CPU从奔腾开始, 内核改用RISC, 外用CISC兼容层也是类似方法。
    - Microsoft的Windows95/nt系统也是以独立兼容层支持DOS和Windows3.1的应用
    - Apple的Mac OS X也是以以独立兼容层支持老产品System OS的应用
    - 集成层类似电商平台(仓库), 一个店铺(子系统)是一个车间, 但每个店铺(或消费者)都只需要通过
      电商平台进行购销活动和交流,无需直接交流,也不需要关注商品(数据)如何形成或流通的细节.
      
#### 和微内核架构的统一

  - 仓库：微内核
  - 车间：插件模块
  - 产品: 消息, 数据
  
#### 和AOP的统一

类似于在一个工业区里, 有一个全局的专业的污水处理厂, 对外部流入的污水分类处理.

- 仓库：
  - 存储有两类数据(产品)
    - 外部输入数据
    - 中间件: 符合数据接口标准的管道函数
  - 数据队列 
    - 单队列或hash-map(分类队列)
    - 接收外部数据.
  - 中间件队列 
    - 单队列或hash-map(分类队列)
    - 支持动态修改
    - 存储中间件

- 车间
  - 接收外部数据
  - 应用中间件处理数据
    - 单队列: 根据输入数据所带的元数据, 选择调用中间件.
    - hash-map(分类队列): 根据输入数据和中间件的键(类型)的映射, 选择调用中间件.
  - 输出到外部的管道函数
     - 单队列: 根据`输出数据`所带的元数据, 选择输出的`外部的管道函数`. 
     - hash-map(分类队列): 根据`输出数据`和`外部的管道函数`的键(类型)的映射, 选择输出的`外部的管道函数`. 
  
#### 和事件驱动架构的统一

- 仓库
  - 数据库有触发器机制
  - Clojure有`add-watch`
- 车间
  - 数据库的触发器
  - Clojure的`watch`函数

#### 和计算机硬件体系的统一

模型以内存作为核心，而不是CPU。
最后,我们可以实现硬件、软件、互联网、物联网等IT全领域的大统一。

- 仓库：内存
- 车间：CPU, 显卡，声卡等。
- 标准化的数据：在符合工业标准接口的硬件间传输的数据
- 验收：主板(带有PCI, SATA, USB等标准化接口)
- 外部的标准化数据：硬盘，闪存盘等
- 后续案例: 在我的计算机硬件架构设计发表一两年后，苹果M1芯片采用了"仓库/车间模型"设计.
  我的架构支持的车间类型比苹果M1广，效率、扩展性和灵活性更强。
  - 仓库: 统一内存
  - 车间: CPU、GPU和其他核心
  - 产品(原材料): 信息, 数据

  > M1芯片有一个新的**统一内存**架构，
  > 让**CPU、GPU和其他核心**之间相互交换**信息**，
  > 通过统一内存，CPU和GPU可以同时访问内存，
  > 而不是在一个区域和另一个区域之间复制数据。
  > 访问同一个内存池，而不需要复制，
  > 加快了信息交换的速度，从而提高整体性能。
  > [参考: 开发者现身说法 苹果M1芯片为何比高端英特尔CPU还要快？](https://finance.sina.com.cn/tech/2020-12-01/doc-iiznezxs4545991.shtml)

- 预测: 我认为Intel、AMD必将采用"仓库/车间模型"

  以前，CPU的性能对计算机的性能起决定性作用，CPU核心少，
  外设的数量和种类也很少，所以CPU成为计算机硬件架构的中心。
  
  现在，CPU和GPU的核心越来越多，外设的数量和种类也越来越多，
  各核心（或部件）的沟通、协调、管理就变得越来越重要，
  成为决定计算机的性能关键因素。
   
  管理科学和计算机科学的核心观点是一致的：都是充分利用可用的资源，
  以最高效率完成目标。通过沟通、协调、管理各种可用的资源完成生产目标
  是管理科学最擅长的领域，最有效、可靠、绝对主流的方式就是"仓库/车间模型"。
  
  所以我认为Intel、AMD必将采用"仓库/车间模型"，
  这是计算机硬件发展的必然趋势。
  
#### 和集成电路系统的统一

  - 仓库：电池
  - 车间：集成电路元件(芯片,板), 电气设备
  - 标准化的数据：电流 
  - 外部的标准化数据：发电厂

#### 和语言平台的统一

  象julia一样搞个lisp为内部核心或内部表示，外用流行语法，这么一来语法特牲完全不是问题，随便增改,
  编译器和语法可以独立演进，齐头并进，自由高效灵活。 可以同时搞几个语言,
  如Julia原生支持julia和lisp语法，还有第三方实现了clojure语法，性能等同原生语法。
  把clojure语法转换成lisp语法，比原生julia语法转换还简单，在一个lisp内部表示的平台上实现一个语言，是很简单的,如Racket.
  不管是喜欢swift,py,ruby,scala,java,f#的哪一种, 统统分别实现一个，统统满足.
  
  - 仓库: 
    - 标准库
    - 外部各种语言编写的编译后以内部lisp表示的库.
    - 本地编译器编译后的库和应用
  - 车间: 
    - 本地编译器: 从仓库获取lisp中间代码, 编译输出到仓库.
    - 内部lisp核心: 用lisp编写代码, 或其他语言编译输出的中间代码.
    - 外部各种语言: 把各语言代码编译输出到仓库, 各语言不必互相交互, 只要与仓库交互即可. racket语言上的多语言即是如此机制.

#### 和Clojure Web应用程序模型的统一

  - 产品标准（数据接口）：ring的req-map和resp-map格式
  - 仓库：ring
  - 车间：C/S两边的函数，通过交互活动通过仓库互相传输原材料（hash-map）。

  因此，我建议使用带有单个hash-map类型参数的函数。
  该参数可以按需映射为标准，数据表，数据库（具有约束，存储过程，模式等）。
  Clojure的不可变永久数据结构不会导致数据克隆，很适合这个场景。

#### 和生命周期管理的统一

  源自流传千百年的中国神话的算法----地狱生死簿。
    
  - 产品(数据): 灵魂(组件)

  - 仓库(数据库): 生死簿, 保存了所有生物(组件)从生到死的
    一切事项和状态,同时可以开触发器监测事件，可以根据事件
    改变生物(组件)的福寿禄(状态和生存期).

  - 车间:   
    - 判官(法官): 组件生命结束时，判官函数根据生死簿赏善罚恶.
    - 孟婆: 让灵魂(组件)恢复初始状态.
    - 六道轮回: 资源池
    - 地狱: 惩罚,销毁, 垃圾回收

#### 与经典AI和现代AI技术的统一

- 仓库
  - 规则库: 经典AI, 专家系统, 逻辑编程
    - 成文法，识别已知模式，更准确
  - 大数据: 现代AI, 机器学习
- 车间
  - 问题求解: 经典AI, 专家系统, 逻辑编程
  - 机器学习: 动态规则库,生成新规则.
    - 判例法，可以识别未知模式，带有不确定性

#### 与能源体系的统一

- 标准化产品: 电能
- 仓库: 电厂, 蓄电池
- 车间
  - 输入车间: 把化学能, 风能, 太阳能, 机械能, 等能源转化成标准能源"电能"
  - 输出车间: 如计算机, 家用电器, 通信设备等各种电气设备, 把标准电能转化成信号,机械能, 声音等. 
  
这个能源体系与金庸武侠小说《天龙八部》里逍遥派的武学体系很相似，
输入车间类似北冥神功，输出车间类似小无相神功。
仓库是丹田气海，标准化产品是北冥真气。
  
#### 与现代经济社会运行体系的统一

- 标准化产品: 货币, 一般等价物
- 仓库: 银行等金融机构
- 车间: 各种政府机构, 企事业单位, 个人.
- 扩展案例: 企业
  - 标准化产品: 货币, 一般等价物
  - 仓库
    - 财务部门: 货币
    - 仓库: 产品, 原材料等
  - 车间: 各种生产部门, 行政部门, 个人.
  

#### 和其他模型的统一

  - 仓库
    - 标准化的数据模型
    - 关系式数据库
  - 车间
    - 纯函数管道数据流
    - 工业生产流水线
    - 船只的水密隔舱
  - 标准化的数据
    - 符合工业标准的产品
      - 原材料
      - 半成品
      - 产成品
  - 验收
    - 质量控制部门
    - 海关
  - 外部的标准化数据
    - 采购部门
    - 供应链

#### 小结

在工业上，产品标准就是接口，生产方法（代码实现）则不受限制，
只要输入符合标准的原材料（数据），输出符合标准的产品（数据）就可以了。

进入仓库前, 所有的数据必须先经过验收.

车间的输入输出只能是标准化数据,
输入的数据来自仓库,输出的数据经过验收后送到仓库.
因此车间内部不会存在异常/错误/非法数据,
无须检测数据.

车间的代码是纯函数管道数据流,
代码简单,可靠,高性能,
易调试,易观测,易维护,易扩展.

车间与车间之间是并行且独立的,不交互,
就象是乐高组件或船只的水密隔舱,
任何一个车间的内部变动或异常不会影响其他车间.


## 它和其它方法的区别

### 函数式编程和面向对象编程的缺点

```
美的主要形式是有序，对称和确定性，数学科学对此有特别的示范。
        ---- 亚里斯多德，《形而上学》
```

只有`纯函数管道数据流和仓库/车间模型`完美地达到要求。
它是`编程之美`的最佳典范.

面向对象和函数式编程完全不符合这三个美的条件，它们代码奇形怪状且逻辑混乱, 不仅不美观, 难以阅读和理解, 
同时也完全不符合工业化大生产简单可重复的要求.

FP和OO过度复杂了，在大工业上是行不通的，还是属于手工作坊那种强调个人技术的生产方式, 个人技术极大影响了产品质量，极不可靠的生产方式。FP和OO其实全是在走弯路, 花拳秀腿,花样作死。

过多的应用OO和FP的各种模式, 除了增加复杂性和出错概率,降低性能, 没有任何好处,
OO系统中对象之间复杂的关系网也是难以维护的.

我倾向于用最简单的概念和最基本的技术、语法和函数构建系统，用来实现我的思想，纯函数管道数据流是最简单、稳定、可靠、可读性强. 在中国有一位伟大的诗人白居易，甚至文盲也理解和欣赏他的诗歌。 我希望即使在最复杂的系统中，初级程序员也能理解我的代码。

### 它和中间件的区别

代码外形看起来相似，但理念是本质上的差别。

- 中间件函数的输入输出是函数，流转的是层层打包的函数，是同心圆，middleware调试是很麻烦的。

- 纯函数管道数据流输入输出是数据，流转的是数据，是线性的串并联。

我不能认同中间件的理念，和集成电路思想是冲突的。电路里，元件（电路板）是无法流转的，
只有数据（电流）才能流转，这是本质的区别。

### 它和Rx的区别

它与[Rx](http://reactivex.io/)本质上是不同的：

- 编程方法之间的本质区别在于内在的思想和模型。 纯函数流水线数据流的思想和模型与集成电路高度一致。

- 纯函数管道数据流强调数据流，Rx强调异步事件流，没有提及或强调数据流。

- 纯函数流水线数据流仅由5个组件组成，模型比Rx简单得多。

- 纯函数流水线数据流强调顺序结构（管道组件的串联），维护（代码读取，扩展，调试等）更简单。

- 纯函数管道数据流的异步事件流比Rx简单。 我在我的项目中编写了一个异步事件流，它只是一个队列处理，简单到没有必要特别提及它。

- Clojure语言根本不需要[RxClojure](https://github.com/ReactiveX/RxClojure)。

### 它和传统FP语言里的类unix管道操作符的区别

- 传统FP语言里的类unix管道操作符

  - 只是简单地模仿自来水管.
  
  - 只作为一个代码片段里的小技巧.

- 纯函数管道数据流

  - 系统性地模拟了集成电路系统和大工业生产流水线.
  
  - 涵盖了系统架构, 数据建模, 数据操纵, 数据应用等一切层面.

    
## 基本质量控制

纯函数管道数据流的基本质量控制, 只有代码达到下面三条基本质量要求, 才可以继续谈其他.
这些简单可靠的评价标准, 足以淘汰绝大多数不合格代码:
- **函数  评价:** 只需要看代码的外形(管道结构比重), 以及函数是不是纯函数.
- **数据流评价:** 最多只有一个副作用,且只能放在末端.
- **系统  评价:** 只看线路图即可, 可以把函数象电子元件一样当黑盒处理.
- **代码质量可视化:** 
  - Lisp类语言的S表达式就是等高线图,可以很简单的变换成等高线图,或3D山峦图.
  - 如果山峦高度不高,且海拔高度值相近,意味着代码质量是好的.
  - 对于非Lisp语言, 则可以先把源代码转换为抽象语法树(AST)，再转换成等高线图,或3D山峦图.

## 编程美学

```
简单、统一、有序、对称和明确
      ---- 林鹏程，编程美学

美的主要形式是有序，对称和确定性，数学科学对此有特别的示范。
      ---- 亚里斯多德，《形而上学》
```
  
我定义的编程美学标准源于科学的基本原则, 
牛顿, 爱因斯坦, 海森堡, 亚里士多德等大科学家都是持这一观点. 

[参考:简单性和统一性](./doc/Simplicity_and_Unity.md)

非艺术类专业的美学很容易流之于复杂和玄学, 让人难以理解和学习, 
纯函数管道数据流提供了简单明了的、科学的、可操作的示范。

## 道

上善若水, 水能按需呈现任何形状, 随心所欲, 千变万化, 顺序前进, 直到完成使命, 到达终点. 
纯函数管道数据流就象水流一样, 近乎于道.

Clojure只是向JVM添加了四个持久集合和一些核心函数，并用四个持久集合表示代码。
它没有语法, 它可以象水流那样, 随需变化, 近乎于道。

大道至简, 道法自然, 道是算法, 道无处不在, 道是一切存在的大统一。
所以, 集成电路技术、工业流水线生产技术、会计学、管理学、建筑学等,
一切都可当成算法和软件工程方法使用, 它们可以互相转化.

在中国传统文化, 对终极大统一 (道)有不懈的追求, 知道这个理念的人有无数个, 
但在历史上, 获得创造性成果的人寥寥无几, 他们都拥有很强的想像力、创造力和理解力. 
每个人的知识、经历、兴趣都不一样, 每个人的道也都具有标志性的个人色彩，
即：只有个性的才是大道的, 类似: 只有民族的才是世界的.

这一层次的成就传统上叫"悟道", 爱因斯坦称之为"真正的智慧". 

![TaoTaiji](./doc/TaoTaiji.gif)


## 杀手级的应用

### 软件设计和开发自动化


```
软件和硬件设计与软件设计师的想法没有什么不同，但与硬件设计师的想法却有很大的不同。
        ---- Fred Brooks, 图灵奖(1999), 人月神话
```

因为`纯函数管道数据流`实现了软硬件在逻辑模型上的统一, 所以它解决了`Fred Brooks`的难题.

- SDDA是一种创新的、革命性的大型软件开发方法
- 纯函数管道数据流是SDDA的基础和唯一正确的方法
- 纯函数管道数据流系统地仿真了集成电路系统, 所以可以就象电子设计自动化（EDA）一样实现SDDA.
- 建立简单、统一、标准化、体系化的管道组件库是SDDA的基础，这也是SDDA的唯一正确的方法。
  就象是EDA一样。
- AI根据初始状态和最终状态的数据标准规范. AI从管道组件库选择组件, 
  组合符合数据标准规范的管道组件以完成任务, 若缺乏相应的管道组件,
  它可以被AI自动生成(或开发人员手工开发).
- 更进一步，集成软件和硬件的设计和开发自动化(HSDDA)。

## 重大历史意义

```
傻瓜忽视复杂性，实用主义者忍受它，有些人能避开它，天才移除它。
      ---- Alan Perlis, Epigrams in Programming(编程警句).
           首届图灵奖得主 (1966)
           使计算机科学成为独立学科的奠基人

当解决方案很简单时，就是上帝在回答。
一切都应该尽可能地简单，且不能再简单。
科学的大多数基本思想本质上都是简单的，通常可以用每个人都可以理解的语言来表达。
如果您不能简单地解释它，则说明您不够了解。
任何一个有智力的笨蛋都可以把事情搞得更大、更复杂、更暴力。往相反的方向前进则需要天份，以及很大的勇气。
      ---- 爱因斯坦
           史上最强民科, 专业的专利局小职员, 业余的物理学家:-)
           1921年诺贝尔物理奖
           
实现民科的伟大复兴 :-)
0. 它是自然科学领域的第一个大统一理论.
1. 以简单和统一的方法完美地击败其他混乱和复杂的软件工程方法学.
2. 实现软硬件在逻辑模型上的统一, 并且通过创新的仓库/车间模型实现编程技术和系统架构的统一.
3. 实现软件生产理论从手工作坊时代到大工业标准化生产时代的飞跃.
4. 软件设计和开发自动化(SDDA)的基础和唯一正确的方法, SDDA是一种创新的、革命性的大型软件开发方法, 就象电子设计自动化（EDA）一样.
5. 定义了编程美学标准是"简单、统一、有序、对称和明确".
6. 这是一项杰出的、引领潮流的技术成就，非常符合"图灵奖"的主要要求。
   我认为它应该获得计算机业最高奖--图灵奖.
   如果我不能获得图灵奖,那一定是ACM缺乏技术鉴赏能力。
   历史将能证明我所说的。2020-03-07
      ---- 林鹏程, 自学成才的民科
```

简单性和统一性的思想是科学研究的重要指导思想.
理论的统一是自然科学的长期目标。现代物理学为其成就提供了壮观的范例。
从各种学科知识中可以发现，越具有普适性的统一理论，就越具有简单性，这样的理论和方法就越基础越伟大。

纯函数管道数据流，基于道家和大统一理论的哲学，
在计算机领域，首次实现了硬件工程与软件工程在逻辑模型上的统一。
它已从“Lisp语言级代码和数据统一”扩展到“系统工程级软件和硬件统一”。
无论是代码的外观还是运行时机制，它都与集成电路系统高度一致。
它还与其他学科（如管理，大型工业流水线，水利工程，电力工程等）广泛统一。
它也非常简单明了，对并发，并行和分布式的支持简单而自然。

只有五个基本组成部分：

1. 管道（纯函数）

2. 分支

3. 回流（反馈，漩涡，递归）

4. 分流（并发，并行）

5. 合流

整个系统由五个基本组成部分组成。它完美地实现了统一性和简单性。它一定会成为终极编程方法学。

另外,IT业作为一门学科，还很年轻，不够成熟， 目前的软件工程还停留在手工作坊水平， 
"纯函数管道数据流"方法的出现，为软件工程带来了大工业生产理论和方法，
把IT业纳入现代大工业生产体系，这是一个划时代的创新的理论和方法。

现代社会是信息社会，IT控制一切, 渗透一切, 我认为，
IT的发展历程与现代大工业生产体系的发展历程是一模一样的。
随着IT业的发展，如国际级、国家级、行业级、企业级的数据标准体系的广泛建立、细化和互联，
"纯函数管道数据流"将成为IT业大工业化生产的基础理论和方法而发挥越来越重要的地位，
并成为终极的标准性的方法进入教科书和工业界。

IT界大工业生产化的关键在于建立象传统工业界的完整的标准体系，如ISO,国标，行标，企标等.
软件件是生产产品（数据）的流水线，这与传统的工业生产流水线没有什么不同。
因此，软件生产方法将采用企业管理理念，将软件开发为类似于工业生产流水线的产品，
输入标准化原材料（数据），输出标准化产品（数据），并将其存储在仓库（数据库）中。

从大工业生产理论来讲，对输入的标准化原材料（数据）和输出的产品(数据)做标准规范，具有如下优点:
- 公平性, 中立性: 使用数据标准规范, 使之对不同的厂家,产品,算法和实现是公平,可以实现良性竞争.
- 可替代性: 只要符合数据标准规范的管道(或产品)即可直接替代.
- 标准性, 数据标准（数据接口，数据规范）比代码接口更好。
- 互联性: 只要符合数据标准规范的管道(或产品)即可互联.
- 组合性: 数据组合优于代码(函数)组合.
- 简单性: 简单是解决方案的最短途径。-- Ward Cunningham (wiki发明者)
- 统一性: 
  - 一切都是管道.
  - 简单和统一的形式是大工业生产的基础.
  - 实现与集成电路, 企业管理, 水力和电力等学科的理论广泛统一, 可以参考它们的理论.
  - 通过创新的仓库/车间模型实现编程技术和系统架构的统一.
- 可预测性: 因为系统架构,设计指南,组件具有简单性和统一性, 非常清晰,所以系统未来的发展变化是可以预测的.
- 可靠性: 简单性是可靠性的前提。-- Edsger W. Dijkstra (1972年获得图灵奖)
- 易扩展: 仅需插入或替换管道而已.
- 易并行: 可以线性扩大生产规模(性能).
- 可观测,易调试,可验证: 管道之间流动的数据非常容易观测, 管道什么位置漏水是一目了然的.
- 清晰性: 非IT从业人员也可理解.
- `编程之美`的最佳典范
  ```
  美的主要形式是有序，对称和确定性，数学科学对此有特别的示范。
        ---- 亚里斯多德，《形而上学》
  ```

  只有`纯函数管道数据流和仓库车间模型`完美地达到要求。
  它是`编程之美`的最佳典范.
  
标准体系的作用,从传统工业界从手工作坊时代进入大工业生产时代后, 社会生产力的巨大进步可以看出来.
这也是中国历史上著名的"车同轨,书同文"的作用.

该方法已应用于10万行代码级的纯Clojure项目，足以证明该方法的实用性。

最后, 如果你同意我的看法，请帮我提名图灵奖。

[如何提名](https://amturing.acm.org/call_for_nominations.cfm)


## 后记

### 想象力

```
想象力比知识更重要。
智力的真正标志不是知识，而是想象力。
逻辑会把你从A带到B，想象力能带你去任何地方。
        ---- 爱因斯坦
```

类似于“代码大全”中最有价值的章节--第2章对软件开发有更深入理解的隐喻，我倾向于激发读者从生活，工作和个人兴趣中发现有用的模式，然后将其作为开发的解决方案，而不是机械地应用其他人的案件。

通过这种方式，将会有无穷无尽的参考案例、无穷无尽的方法来解决问题。这就是“道”。

### 道法自然，千变万化

有人问我为什么不象OO和FP一样，搞几个管道流的设计模式，我不禁想到《西游记》中菩提祖师问猴子要学天罡36变，还是地煞72变，
当猴子选择72变时，他的失败已成定局，作为道家大能的菩提祖师，不会不懂道法自然，千变万化的道理，
不管猴子选36变，还是72变，他的思想从此受到窒梏，戴上无形的紧㧜咒，从此无缘大道，这不是教学，而是耍猴。:-)

当然, 事情也可以从另一个角度来讲，子曰： “不愤不启，不悱不发，举一隅不以三隅反，则不复也。”老子曰：“道可道，非常道。”
因为猴子优秀的身体资质，被菩提祖师收入门墙，因为道只可意会，不可言传，因此给了猴子72次机会，以72变为例启发猴子悟道，
可惜，猴子悟性太差，只是一台完美的复印机，没有任何创新能力，不能举一反三，始终不能悟道，
最终菩提祖师绝望了，明白了猴子不能悟道继承他的衣钵，达不到做他弟子的标准，
就把猴子逐出门墙，不许猴子称他为师傅，即猴子是肆业，甚至是不光彩地被劝退，而不是毕业。

### 大道至简，易学难精。

老子曰：“吾言甚易知甚易行，天下莫能知莫能行。”
即：大道至简，易学难精。
纯管道系统是一个简单的系统，但简单并不意味着容易。实现纯管道系统是一个系统性的工程,必须进行艰苦的努力,
才能做到把一个复杂的系统建设成一个简单流畅的纯管道系统.
这需要大智慧,并且付出很多的艰难的业务流程设计(或重组)工作.

另外，就是要养成并保持良好的开发习惯，
做一件好事很容易，但一辈子做好事很难，
写一个管道纯函数很容易，坚持写纯管道系统不容易。
对本法有兴趣的人，可以坚持多应用，熟能生巧，功到自然成。

```
尽道圣贤须有秘，翻嫌易简却求难。
        ---- 王阳明
```

大家只要认真看过“纯函数管道数据流”，就会发现我只使用最基础的常识来解决问题，并没有使用任何太过复杂精巧的技术。
常识是人类最佳实践或应用最广泛和最可靠的理论。

### 基于原则比基于规则更好。

- 原则应该很少且重要, 不应影响灵活性和创造力, 以达到随心所欲而不逾矩的效果。例如：不要超过10条原则。

- 原则应该简单、清楚，并且必须确保强制执行。。

- 太多的规则等于没有规则, 复杂且难以执行, 增加漏洞的概率, 影响了灵活性和创造力。

- 实施软件工程如同带兵打仗, 太多太复杂的军纪, 大头兵是难以理解和执行的, 最终效果很差.

- 简单性和统一性必须平行。纯管道系统符合此原则。

- 原则应与现代工业生产的主流原则相一致。

### 结尾

我利用业余时间开发财务分析专家系统。虽然我写作时间有限，但我会逐步改进它，
相比我第一次设置博客时的内容，它已经丰富和改进了很多。


## 其他文章目录

### English + Chinese

- [不破坏编程语言语法的Markdown文学编程](doc/markdown_literary_programming.md)

- [~~引论: 基本构造方法(老版本)~~](doc/IntroductionBasicMethods.md)

- [注解是不必要的技术](doc/annotation_is_unnecessary.md)

- [Clojure是基于关系式数据库理论的函数式编程语言](doc/Clojure_is_FP_based_on_RMDB.md)

- [一切都是RMDB](doc/Everything_is_RMDB.md)

- [数学与《天龙八部》小无相功：从AI的角度看，所有的专业都是穿着马甲的数学。](doc/math-xiaoyao.md)

- [为什么 Clojure (Lisp) 近乎于道?](doc/why_clojure_almost_the_Tao.md)

- [Clojure最佳实践](doc/best_practice_of_clojure.md)

- [Clojure的一种可能的路线图.](doc/clj_possible.md)

- [动静态交互(太极与乒乓球)](doc/interaction_of_static_and_dynamic.md)

- [Rust: 数学不能救编程，但财务可以](doc/rust.md)

- [React很糟糕](doc/react_is_terrible.md)

### Chinese

- [简单性和统一性----大统一理论, Lisp(Clojure) 与纯函数管道数据流](doc/Simplicity_and_Unity.md)

- [儒家大统一之道--学科融合(国际疾病分类、AI、数学、会计与纯函数管道数据流)](doc/Tao_ICD.md)

- [证“立德、立功、立言”三不朽](doc/immortal.md)

- [国际疾病分类(ICD)编码、主诊选择、DRGs费用结算、医疗服务、医学知识大统一 ---- 纯函数管道数据流和仓库/车间模型大统一系列](doc/unification_ICD_dataflow.md)

- [函数式编程、面向对象、数据流的差异](doc/fp_oo_dataflow.md)

- [`纯函数管道数据流`与《天龙八部》逍遥派武学体系](doc/dataflow_xiaoyao.md)

- [Office是数据库服务](doc/office_is_db.md)

- [数据模型是全局的、战略的，而函数实现只是局部的、战术的](doc/datamodel-vs-function.md)

- [英雄所见略同：Rob Pike，Linus Torvalds，Alan Perlis 和我](doc/RobPike-LinusTorvalds-AlanPerlis-Me.md)

- [纯函数管道数据流串并联集成系统法](doc/DataflowIC.md)

- [论纯函数管道数据流方法，兼评：左耳朵耗子 《什么是函数式编程？》](doc/AboutDataflow.md)

- [函数式编程学套路还是学无限法？](doc/infinite.md)

- [代码也是头等公民](doc/code-is-first-class.md)

- [《代码大全》与“想像力编程”](doc/CodeComplete.md)

- [《计算机编程的艺术》与想象力编程](doc/TAOCP.md)

- [神话编程：生死簿、轮回、地狱](doc/LifecycleManagement.md)

- [半自动步枪、批处理和Lazy](doc/lazy.md)

- [如来神掌与tree-seq](doc/tree-seq-and-The-Hand-of-God.md)

- [C#愚蠢到我不能理解，兼论UI构造方法](doc/c%23stupid.md)

- [Google Flutter是一种我曾原创并已淘汰的类似技术](doc/Flutter_is_outdated.md)

- [例解：抽象、多态、变态](doc/Ii-abstract.md)

- [我的项目技术架构：AI、统计、杀毒软件](doc/TechnicalFramework.md)

- [`吾道一以贯之`与`至诚之道`](doc/sincerity.md)
